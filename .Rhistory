colnames(coords) = c('R', 'r', 'theta', 'phi')
return(coords)
}
coords_p = cbind(6, 2, matrix(runif(200, 0, 2*pi), ncol = 2))
View(coords_p)
coords_c = polar2Cartesian(coords_p)
View(coords_c)
coords_p2 = cartesian2Polar(coords_c, 6,2)
# function to transform (x, y, z) coordinate to (R, r, theta, phi) coordinate
cartesian2Polar <- function(coords_xyz, R, r) {
x = coords_xyz[, 1]; y = coords_xyz[, 2]; z = coords_xyz[, 3];
comp = complex(real = x, imaginary = y)
phi = Arg(comp); mod = Mod(comp)
theta0 = asin(z / r)
theta = ifelse(z >= 0, ifelse(mod <= R, theta0, pi - theta0), 2 * pi + theta0)
coords = cbind(R, r, theta, phi)
colnames(coords) = c('R', 'r', 'theta', 'phi')
return(coords)
}
coords_p2 = cartesian2Polar(coords_c, 6,2)
identical(coords_p, coords_p2)
all(coords_p == coords_p2)
View(coords_p)
View(coords_p2)
# function to transform (R, r, theta, phi) coordinate to (x, y, z) coordinate
polar2Cartesian <- function(coords_polar) {
R = coords_polar[, 1]; r = coords_polar[, 2]
theta = coords_polar[, 3]; phi = coords_polar[, 4]
x = cos(phi) * (R + r * cos(theta))
y = sin(phi) * (R + r * cos(theta))
z = r * sin(theta)
coords = cbind(x, y, z)
colnames(coords) = c('x', 'y', 'z')
return(coords)
}
# function to transform (x, y, z) coordinate to (R, r, theta, phi) coordinate
cartesian2Polar <- function(coords_xyz, R, r) {
x = coords_xyz[, 1]; y = coords_xyz[, 2]; z = coords_xyz[, 3];
comp = complex(real = x, imaginary = y)
phi = Arg(comp); mod = Mod(comp)
theta0 = asin(z / r)
theta = ifelse(z >= 0, ifelse(mod <= R, theta0, pi - theta0), 2 * pi + theta0)
coords = cbind(R, r, theta, phi)
colnames(coords) = c('R', 'r', 'theta', 'phi')
return(coords)
}
coords_c = polar2Cartesian(coords_p)
coords_p2 = cartesian2Polar(coords_c, 6,2)
all(coords_p == coords_p2)
View(coords_c)
View(coords_p)
View(coords_p2)
View(coords_c)
?Arg
View(coords_p)
View(coords_p2)
View(coords_p)
comp = complex(imaginary = -3.806637784, real = -1.40187371)
Arg(comp)
comp = complex(imaginary = 3.806637784, real = -1.40187371)
Arg(comp)
comp = complex(imaginary = -3.806637784, real = 1.40187371)
Arg(comp)
# function to transform (x, y, z) coordinate to (R, r, theta, phi) coordinate
cartesian2Polar <- function(coords_xyz, R, r) {
x = coords_xyz[, 1]; y = coords_xyz[, 2]; z = coords_xyz[, 3];
comp = complex(real = x, imaginary = y)
phi0 = Arg(comp); mod = Mod(comp)
phi = ifelse(phi0 >= 0, phi0, 2 * pi - phi0)
theta0 = asin(z / r)
theta = ifelse(z >= 0, ifelse(mod <= R, theta0, pi - theta0), 2 * pi + theta0)
coords = cbind(R, r, theta, phi)
colnames(coords) = c('R', 'r', 'theta', 'phi')
return(coords)
}
coords_p2 = cartesian2Polar(coords_c, 6,2)
View(coords_p)
View(coords_p2)
View(coords_c)
1.5*pi
# function to transform (R, r, theta, phi) coordinate to (x, y, z) coordinate
polar2Cartesian <- function(coords_polar) {
R = coords_polar[, 1]; r = coords_polar[, 2]
theta = coords_polar[, 3]; phi = coords_polar[, 4]
x = cos(phi) * (R + r * cos(theta))
y = sin(phi) * (R + r * cos(theta))
z = r * sin(theta)
coords = cbind(x, y, z)
colnames(coords) = c('x', 'y', 'z')
return(coords)
}
# function to transform (x, y, z) coordinate to (R, r, theta, phi) coordinate
cartesian2Polar <- function(coords_xyz, R, r) {
x = coords_xyz[, 1]; y = coords_xyz[, 2]; z = coords_xyz[, 3];
comp = complex(real = x, imaginary = y)
phi0 = Arg(comp); mod = Mod(comp)
phi = ifelse(phi0 >= 0, phi0, 2 * pi - phi0)
theta0 = asin(z / r)
theta = ifelse(z >= 0, ifelse(mod >= R, theta0, pi - theta0), 2 * pi + theta0)
coords = cbind(R, r, theta, phi)
colnames(coords) = c('R', 'r', 'theta', 'phi')
return(coords)
}
coords_c = polar2Cartesian(coords_p)
coords_p2 = cartesian2Polar(coords_c, 6,2)
View(coords_c)
View(coords_p)
View(coords_p2)
comp = complex(real=-3.65432064,
imaginary = 1.937094986)
Mod(Comp)
Mod(comp)
# function to transform (x, y, z) coordinate to (R, r, theta, phi) coordinate
cartesian2Polar <- function(coords_xyz, R, r) {
x = coords_xyz[, 1]; y = coords_xyz[, 2]; z = coords_xyz[, 3];
comp = complex(real = x, imaginary = y)
phi0 = Arg(comp); mod = Mod(comp)
phi = ifelse(phi0 >= 0, phi0, 2 * pi - phi0)
theta0 = asin(z / r)
# theta = ifelse(z >= 0, ifelse(mod >= R, theta0, pi - theta0), 2 * pi + theta0)
theta = ifelse(mod < R, pi - theta0,
ifelse(z >= 0, theta0, 2 * pi + theta0))
coords = cbind(R, r, theta, phi)
colnames(coords) = c('R', 'r', 'theta', 'phi')
return(coords)
}
coords_p2 = cartesian2Polar(coords_c, 6,2)
View(coords_p2)
comp = complex(real=2.39721399,
imaginary = 7.482301204)
Arg(comp)
comp = complex(real=2.39721399,
imaginary = -7.482301204)
Arg(comp)
# function to transform (x, y, z) coordinate to (R, r, theta, phi) coordinate
cartesian2Polar <- function(coords_xyz, R, r) {
x = coords_xyz[, 1]; y = coords_xyz[, 2]; z = coords_xyz[, 3];
comp = complex(real = x, imaginary = y)
phi0 = Arg(comp); mod = Mod(comp)
phi = ifelse(phi0 >= 0, phi0, 2 * pi + phi0)
theta0 = asin(z / r)
# theta = ifelse(z >= 0, ifelse(mod >= R, theta0, pi - theta0), 2 * pi + theta0)
theta = ifelse(mod < R, pi - theta0,
ifelse(z >= 0, theta0, 2 * pi + theta0))
coords = cbind(R, r, theta, phi)
colnames(coords) = c('R', 'r', 'theta', 'phi')
return(coords)
}
coords_p2 = cartesian2Polar(coords_c, 6,2)
View(coords_p2)
any(coords_p == coords_p2)
plot(coords_c[, 1:2])
plot(coords_c[, 2:3])
plot(coords_c[, c(1,3)])
A = matrix(runif(100^4), nrow = 10000. ncol = 10000)
A = matrix(runif(100^4), nrow = 10000, ncol = 10000)
rm(A)
library(FNN)
get.knnx()
?get.knnx()
require(Matrix)
sparseMatrix(i = c(1, 1, 2, 3), j = c(1, 2, 1, 2), x= 1:4, dims = c(4,4), symmetric = T)
sparseMatrix(i = c(1, 1, 2, 3), j = c(1, 2, 1, 2), x= 1:4, dims = c(4,4), symmetric = F)
sparseMatrix(i = c(1, 1, 1, 2), j = c(1, 2, 2, 3), x= 1:4, dims = c(4,4), symmetric = T)
library(igraph)
g <- make_ring(10)
al <- as_adj_list(g)
al
class(al)
class(al[[1]])
al = lapply(al, as.numeric)
al
al = al[[-10]]
al = al[-10]
al
al[[10]] = c(1, 9)
plot(graph_from_adj_list(al, mode = 'all'))
al[[10]] = c(1, 9, 2)
plot(graph_from_adj_list(al, mode = 'all'))
al
plot(graph_from_adj_list(al, mode = 'total'))
plot(graph_from_adj_list(al, mode = 'all', duplicate = F))
plot(simplify(graph_from_adj_list(al, mode = 'all', duplicate = F)))
A
A = sparseMatrix(i = c(1, 1, 2, 3), j = c(1, 2, 1, 2), x= 1:4, dims = c(4,4), symmetric = F)
?apply
A = matrix(1:6, 2, 3)
A
cbind(A, matrix(0, 2, -))
cbind(A, matrix(0, 2, 0))
source('~/_TAMU/Projects/BAST/code/BASTFun4.R')
source('~/_TAMU/Projects/BAST/code/BASTFun4.R')
source('~/_TAMU/Projects/BAST/code/BASTFun4.R')
source('~/_TAMU/Projects/BAST/code/BASTFun4.R')
source('~/_TAMU/Projects/BAST/code/BASTFun4.R')
library(devtools)
install_github("theodds/SoftBART")
library(rlang)
library(devtools)
install_github("theodds/SoftBART")
library(devtools)
install_github("theodds/SoftBART")
install.packages('roxygen2')
params_all = expand.grid(
M = c(20, 30, 50),
k_max = c(5, 10),
a = 1:3
)
View(params_all)
?choose
choose(58, 18)*3/choose(60, 20)
Sys.time()
t = Sys.time()
Sys.time() - t
class(Sys.time() - t)
?difftime
ts = POSIXlt(10)
timediff(Sys.time(), t, units = 'secs')
difftime(Sys.time(), t, units = 'secs')
as.numeric(difftime(Sys.time(), t, units = 'secs'))
Sys.time() - t
### Simulation data on U-shape domain ###
rm(list=ls())
setwd('D:\\Documents\\_TAMU\\Projects\\Github\\BAMDT')
library(ggplot2)
source('ComplexDomainFun.R')
### generate data ----
set.seed(1234)
# generate U-shaped domain
rot_angle = 45
ubnd = genURegion(angle = rot_angle, n_line = 14)
# generate n uniform training locations
n = 500
coords = genLocations(n, ubnd)
# generate n_ho uniform hold-out locations
n_ho = 200
coords_ho = genLocations(n_ho, ubnd)
# estimate geodesic distance between observed/testing locations
coords_all = rbind(coords, coords_ho)
dist_res = gdist(coords_all, ubnd)
dist_mat_all = dist_res[1:(n + n_ho), 1:(n + n_ho)]
rm(dist_res)
# generate X from GP
set.seed(1234)
p = 10
X_all = matrix(0, nrow = n + n_ho, ncol = p)
X_all = simGpU(p, coords_all, angle = rot_angle)
colnames(X_all) = paste("X", 1:p, sep = "")
X = X_all[1:n, , drop = F]
X_ho = X_all[-(1:n), , drop = F]
# check what X[, 1] looks like
ggplot() +
geom_boundary(ubnd) +
geom_point(aes(x = lon, y = lat, color = X[, 1]), data = as.data.frame(coords)) +
scale_color_gradientn(colours = rainbow(5))
# generate true function
f_true = evalFunU(coords, X, angle = rot_angle)
f_ho_true = evalFunU(coords_ho, X_ho, angle = rot_angle)
# true partition
cluster_true = ifelse(coords[, 1] ^ 2 + coords[, 2] ^ 2 <= 0.9^2, 1, 0)
idx = cluster_true == 0
cluster_true[idx] = ifelse(coords[idx, 1] > coords[idx, 2], 2, 3)
cluster_ho_true = ifelse(coords_ho[, 1] ^ 2 + coords_ho[, 2] ^ 2 <= 0.9^2, 1, 0)
idx = cluster_ho_true == 0
cluster_ho_true[idx] = ifelse(coords_ho[idx, 1] > coords_ho[idx, 2], 2, 3)
# modify true function to create discontinuity
f_true[cluster_true == 3] = f_true[cluster_true == 3] - 4
f_true[cluster_true == 2] = f_true[cluster_true == 2] + 4
f_true[cluster_true == 1] = -0.5 * f_true[cluster_true == 1]
f_ho_true[cluster_ho_true == 3] = f_ho_true[cluster_ho_true == 3] - 4
f_ho_true[cluster_ho_true == 2] = f_ho_true[cluster_ho_true == 2] + 4
f_ho_true[cluster_ho_true == 1] = -0.5 * f_ho_true[cluster_ho_true == 1]
# check what the true function looks like
ggplot() +
geom_boundary(ubnd) +
geom_ellipse(0.9, 0.9, 0, 0) +
geom_point(aes(x = lon, y = lat, col = f_true), data = as.data.frame(coords)) +
scale_color_gradientn(colours = rainbow(5), name = 'True f')
# generate replicate data sets
n_rep = 50
Y_rep = matrix(0, nrow = n_rep, ncol = n)
Y_ho_rep = matrix(0, nrow = n_rep, ncol = n_ho)
for (i in 1:n_rep) {
Y = f_true + rnorm(n, 0, 0.1)
Y_ho = f_ho_true + rnorm(n_ho, 0, 0.1)
Y_rep[i, ] = Y
Y_ho_rep[i, ] = Y_ho
}
# save data
save(Y_rep, Y_ho_rep, X, coords, n, p, ubnd,
X_ho, coords_ho, n_ho, dist_mat_all,
file = "input_U.RData", compress = "bzip2")
##### Demo code for BAMDT ######
rm(list=ls())
setwd('D:\\Documents\\_TAMU\\Projects\\Github\\BAMDT')
library(ggplot2)
source('ComplexDomainFun.R')
source('Trees.R')
source('Model.R')
### Get model inputs -----
load("input_U.RData")
# get initial values
init_val = list()
init_val[['sigmasq_y']] = 1  # initial value for noise variance
nu = 3; q = 0.9
M = 50
hyperpar = c()
hyperpar['sigmasq_mu'] = (0.5/(2*sqrt(M)))^2          # variance of prior for mu
hyperpar['q'] = q                                     # quantile in prior for noise variance
hyperpar['nu'] = nu                                   # degree of freedom in prior for noise variance
hyperpar['M'] = M                                     # number of trees
hyperpar['alpha'] = 0.95                              # hyperparameter in tree generating process
hyperpar['beta'] = 2                                  # hyperparameter in tree generating process
hyperpar['numcut'] = 100                              # number of candidate cutting points for x
hyperpar['prob_split_by_x'] = min(p / (p + 2), 0.85)  # probability for a split on x
# make graph on spatial knots
n_knot = rep(100, M)  # numver of knots for each tree
coords_knots = list() # knot coordinates for each tree
graphs = list()       # spatial graph for each tree
knot_idx = list()     # indices of knots in training locations
set.seed(1234)
for (m in 1:M) {
# subsample training locations as knots
knot_idx[[m]] = sample.int(n, n_knot[m])
coords_knots[[m]] = coords[knot_idx[[m]], ]
dist_mat_knot = dist_mat_all[knot_idx[[m]], knot_idx[[m]]]
# get CDT graph on knots
mesh = gen2dMesh(coords_knots[[m]], ubnd)
graph0 = constrainedDentri(n_knot[m], mesh,
gaurantee_connected = T, dist_mat = dist_mat_knot)
E(graph0)$eid = as.integer(1:ecount(graph0))  # edge id
V(graph0)$vid = as.integer(1:vcount(graph0))  # vertex id
graphs[[m]] = graph0
}
# ensuring spatial graphs are connected
for (m in 1:M) {
if (components(graphs[[m]])$no != 1)
stop(paste("Disconnected graph:", m))
}
# assign observations to their nearest knots
# projections[i, j] is the index of the nearest knot of obs. i in weak learner j
# similirly, projections_ho is for hold-out locations
projections_ho = array(0, dim = c(n_ho, 1, M))
for (m in 1:M) {
# get distance between training locations and knots
cdist_mat_knots = dist_mat_all[ 1:n, knot_idx[[m]] ]
projections[, m] = apply(cdist_mat_knots, 1, which.min)
# get distance between hold-out locations and knots
cdist_mat_ho_knots = dist_mat_all[ (n + 1):(n + n_ho), knot_idx[[m]] ]
projections_ho[, , m] = apply(cdist_mat_ho_knots, 1, which.min)
}
##### Demo code for BAMDT ######
rm(list=ls())
setwd('D:\\Documents\\_TAMU\\Projects\\Github\\BAMDT')
library(ggplot2)
source('ComplexDomainFun.R')
source('Trees.R')
source('Model.R')
### Get model inputs -----
load("input_U.RData")
# get initial values
init_val = list()
init_val[['sigmasq_y']] = 1  # initial value for noise variance
nu = 3; q = 0.9
M = 50
hyperpar = c()
hyperpar['sigmasq_mu'] = (0.5/(2*sqrt(M)))^2          # variance of prior for mu
hyperpar['q'] = q                                     # quantile in prior for noise variance
hyperpar['nu'] = nu                                   # degree of freedom in prior for noise variance
hyperpar['M'] = M                                     # number of trees
hyperpar['alpha'] = 0.95                              # hyperparameter in tree generating process
hyperpar['beta'] = 2                                  # hyperparameter in tree generating process
hyperpar['numcut'] = 100                              # number of candidate cutting points for x
hyperpar['prob_split_by_x'] = min(p / (p + 2), 0.85)  # probability for a split on x
# make graph on spatial knots
n_knot = rep(100, M)  # numver of knots for each tree
coords_knots = list() # knot coordinates for each tree
graphs = list()       # spatial graph for each tree
knot_idx = list()     # indices of knots in training locations
set.seed(1234)
for (m in 1:M) {
# subsample training locations as knots
knot_idx[[m]] = sample.int(n, n_knot[m])
coords_knots[[m]] = coords[knot_idx[[m]], ]
dist_mat_knot = dist_mat_all[knot_idx[[m]], knot_idx[[m]]]
# get CDT graph on knots
mesh = gen2dMesh(coords_knots[[m]], ubnd)
graph0 = constrainedDentri(n_knot[m], mesh,
gaurantee_connected = T, dist_mat = dist_mat_knot)
E(graph0)$eid = as.integer(1:ecount(graph0))  # edge id
V(graph0)$vid = as.integer(1:vcount(graph0))  # vertex id
graphs[[m]] = graph0
}
# ensuring spatial graphs are connected
for (m in 1:M) {
if (components(graphs[[m]])$no != 1)
stop(paste("Disconnected graph:", m))
}
# assign observations to their nearest knots
# projections[i, j] is the index of the nearest knot of obs. i in weak learner j
# similirly, projections_ho is for hold-out locations
projections = array(0, dim = c(n, 1, M))
projections_ho = array(0, dim = c(n_ho, 1, M))
for (m in 1:M) {
# get distance between training locations and knots
cdist_mat_knots = dist_mat_all[ 1:n, knot_idx[[m]] ]
projections[, m] = apply(cdist_mat_knots, 1, which.min)
# get distance between hold-out locations and knots
cdist_mat_ho_knots = dist_mat_all[ (n + 1):(n + n_ho), knot_idx[[m]] ]
projections_ho[, , m] = apply(cdist_mat_ho_knots, 1, which.min)
}
M
projections_new
A = array(1:6, dim = c(2, 3))
A
B = array(A, dim(2,1,3))
B = array(A, dim = dim(2,1,3))
B = array(A, dim = c(2,1,3))
B
B[,1,]
A
##### Demo code for BAMDT ######
rm(list=ls())
setwd('D:\\Documents\\_TAMU\\Projects\\Github\\BAMDT')
library(ggplot2)
source('ComplexDomainFun.R')
source('Trees.R')
source('Model.R')
### Get model inputs -----
load("input_U.RData")
# get initial values
init_val = list()
init_val[['sigmasq_y']] = 1  # initial value for noise variance
nu = 3; q = 0.9
M = 50
hyperpar = c()
hyperpar['sigmasq_mu'] = (0.5/(2*sqrt(M)))^2          # variance of prior for mu
hyperpar['q'] = q                                     # quantile in prior for noise variance
hyperpar['nu'] = nu                                   # degree of freedom in prior for noise variance
hyperpar['M'] = M                                     # number of trees
hyperpar['alpha'] = 0.95                              # hyperparameter in tree generating process
hyperpar['beta'] = 2                                  # hyperparameter in tree generating process
hyperpar['numcut'] = 100                              # number of candidate cutting points for x
hyperpar['prob_split_by_x'] = min(p / (p + 2), 0.85)  # probability for a split on x
# make graph on spatial knots
n_knot = rep(100, M)  # numver of knots for each tree
coords_knots = list() # knot coordinates for each tree
graphs = list()       # spatial graph for each tree
knot_idx = list()     # indices of knots in training locations
set.seed(1234)
for (m in 1:M) {
# subsample training locations as knots
knot_idx[[m]] = sample.int(n, n_knot[m])
coords_knots[[m]] = coords[knot_idx[[m]], ]
dist_mat_knot = dist_mat_all[knot_idx[[m]], knot_idx[[m]]]
# get CDT graph on knots
mesh = gen2dMesh(coords_knots[[m]], ubnd)
graph0 = constrainedDentri(n_knot[m], mesh,
gaurantee_connected = T, dist_mat = dist_mat_knot)
E(graph0)$eid = as.integer(1:ecount(graph0))  # edge id
V(graph0)$vid = as.integer(1:vcount(graph0))  # vertex id
graphs[[m]] = graph0
}
# ensuring spatial graphs are connected
for (m in 1:M) {
if (components(graphs[[m]])$no != 1)
stop(paste("Disconnected graph:", m))
}
# assign observations to their nearest knots
# projections[i, j] is the index of the nearest knot of obs. i in weak learner j
# similirly, projections_ho is for hold-out locations
projections = array(0, dim = c(n, M))
projections_ho = array(0, dim = c(n_ho, M))
for (m in 1:M) {
# get distance between training locations and knots
cdist_mat_knots = dist_mat_all[ 1:n, knot_idx[[m]] ]
projections[, m] = apply(cdist_mat_knots, 1, which.min)
# get distance between hold-out locations and knots
cdist_mat_ho_knots = dist_mat_all[ (n + 1):(n + n_ho), knot_idx[[m]] ]
projections_ho[, m] = apply(cdist_mat_ho_knots, 1, which.min)
}
Y = Y_rep[1, ]; Y_ho = Y_ho_rep[1, ]
# MCMC iterations
MCMC = 1000
BURNIN = 500
THIN = 5
# train BAMDT and predict for hold-out data
model = Model$new(Y, X, graphs, projections, hyperpar, X_ho, projections_ho)
model$Fit(init_val, MCMC, BURNIN, THIN, seed = 12345)
# get posterior mean prediction
Y_ho_hat = colMeans(model$Y_new_out)
# plot prediction
ggplot() +
geom_boundary(bnd) +
geom_point(aes(x = lon, y = lat, col = Y_ho_hat),
data = as.data.frame(coords_ho)) +
scale_color_gradientn(colors = rainbow(5)) +
ggtitle('Prediction of BAMDT')
# plot prediction
ggplot() +
geom_boundary(ubnd) +
geom_point(aes(x = lon, y = lat, col = Y_ho_hat),
data = as.data.frame(coords_ho)) +
scale_color_gradientn(colors = rainbow(5)) +
ggtitle('Prediction of BAMDT')
# check feature importance
colMeans(model$importance)
model$importance
# check feature importance
colMeans(model$importance_out)
?wbart
p / (p + 2)
